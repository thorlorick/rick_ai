// backend/services/queryService.js

const mysql = require('mysql2/promise');
const config = require('../config/rickConfig');
const { validateAndPrepareSQL } = require('../utils/sqlValidator');

// Create connection pool for RICK read-only user
const pool = mysql.createPool({
  host: config.database.host,
  user: config.database.user,
  password: config.database.password,
  database: config.database.database,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

/**
 * Pre-defined queries for quick actions
 */
const PREDEFINED_QUERIES = {
  struggling_students: (teacherId) => ({
    sql: `
      SELECT s.id, s.name, s.email, AVG(g.grade) as average_grade
      FROM students s
      JOIN grades g ON s.id = g.student_id
      WHERE s.teacher_id = ? AND g.teacher_id = ?
      GROUP BY s.id, s.name, s.email
      HAVING average_grade < 60
      ORDER BY average_grade ASC
      LIMIT 10
    `,
    params: [teacherId, teacherId]
  }),
  
  missing_assignments: (teacherId) => ({
    sql: `
      SELECT s.id, s.name, COUNT(DISTINCT a.id) as missing_count
      FROM students s
      CROSS JOIN assignments a
      LEFT JOIN grades g ON s.id = g.student_id AND a.id = g.assignment_id
      WHERE s.teacher_id = ? AND a.teacher_id = ?
        AND g.id IS NULL
      GROUP BY s.id, s.name
      HAVING missing_count > 0
      ORDER BY missing_count DESC
      LIMIT 10
    `,
    params: [teacherId, teacherId]
  }),
  
  attendance_issues: (teacherId) => ({
    sql: `
      SELECT s.id, s.name, 
             COUNT(CASE WHEN at.status = 'absent' THEN 1 END) as absent_count,
             COUNT(CASE WHEN at.status = 'late' THEN 1 END) as late_count
      FROM students s
      LEFT JOIN attendance at ON s.id = at.student_id
      WHERE s.teacher_id = ? AND at.teacher_id = ?
      GROUP BY s.id, s.name
      HAVING absent_count > 3 OR late_count > 5
      ORDER BY absent_count DESC, late_count DESC
      LIMIT 10
    `,
    params: [teacherId, teacherId]
  }),
  
  class_average: (teacherId) => ({
    sql: `
      SELECT 
        AVG(g.grade) as class_average,
        MIN(g.grade) as lowest_grade,
        MAX(g.grade) as highest_grade,
        COUNT(DISTINCT s.id) as student_count
      FROM grades g
      JOIN students s ON g.student_id = s.id
      WHERE g.teacher_id = ? AND s.teacher_id = ?
    `,
    params: [teacherId, teacherId]
  }),
  
  recent_improvements: (teacherId) => ({
    sql: `
      SELECT s.id, s.name, 
             AVG(CASE WHEN g.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY) 
                  THEN g.grade END) as recent_avg,
             AVG(CASE WHEN g.created_at < DATE_SUB(NOW(), INTERVAL 30 DAY) 
                  THEN g.grade END) as older_avg
      FROM students s
      JOIN grades g ON s.id = g.student_id
      WHERE s.teacher_id = ? AND g.teacher_id = ?
      GROUP BY s.id, s.name
      HAVING recent_avg > older_avg + 5
      ORDER BY (recent_avg - older_avg) DESC
      LIMIT 10
    `,
    params: [teacherId, teacherId]
  }),
  
  assignment_completion: (teacherId) => ({
    sql: `
      SELECT a.id, a.name, a.due_date,
             COUNT(DISTINCT g.student_id) as completed_count,
             (SELECT COUNT(*) FROM students WHERE teacher_id = ?) as total_students,
             ROUND(COUNT(DISTINCT g.student_id) * 100.0 / 
                   (SELECT COUNT(*) FROM students WHERE teacher_id = ?), 1) as completion_rate
      FROM assignments a
      LEFT JOIN grades g ON a.id = g.assignment_id
      WHERE a.teacher_id = ?
      GROUP BY a.id, a.name, a.due_date
      ORDER BY a.due_date DESC
      LIMIT 10
    `,
    params: [teacherId, teacherId, teacherId]
  })
};

/**
 * Execute a pre-defined query
 */
const executePredefinedQuery = async (queryType, teacherId) => {
  try {
    const queryDef = PREDEFINED_QUERIES[queryType];
    
    if (!queryDef) {
      return {
        success: false,
        error: `Unknown query type: ${queryType}`,
        results: []
      };
    }
    
    const { sql, params } = queryDef(teacherId);
    
    const [results] = await pool.execute(sql, params);

    return {
      success: true,
      results: results,
      queryType: queryType
    };
  } catch (error) {
    console.error('Error executing predefined query:', error);
    return {
      success: false,
      error: error.message,
      results: []
    };
  }
};

/**
 * Execute a dynamic SQL query (generated by Ollama)
 */
const executeDynamicQuery = async (sql, teacherId) => {
  try {
    // Validate and prepare SQL
    const validation = validateAndPrepareSQL(sql, teacherId);
    
    if (!validation.success) {
      return {
        success: false,
        error: validation.error,
        results: []
      };
    }
    
    // Execute with timeout
    const connection = await pool.getConnection();
    
    try {
      // Set query timeout
      await connection.query(`SET SESSION max_execution_time = ${config.security.queryTimeout}`);
      
      const [results] = await connection.execute(validation.sql);
      
      connection.release();
      
      return {
        success: true,
        results: results,
        executedSQL: validation.sql
      };
    } catch (queryError) {
      connection.release();
      throw queryError;
    }
  } catch (error) {
    console.error('Error executing dynamic query:', error);
    return {
      success: false,
      error: error.message,
      results: []
    };
  }
};

/**
 * Test database connection
 */
const testConnection = async () => {
  try {
    const [result] = await pool.execute('SELECT 1 as test');
    return {
      success: true,
      message: 'Database connection successful'
    };
  } catch (error) {
    console.error('Database connection error:', error);
    return {
      success: false,
      error: error.message
    };
  }
};

/**
 * Get available predefined queries
 */
const getAvailableQueries = () => {
  return Object.keys(PREDEFINED_QUERIES).map(key => ({
    id: key,
    name: key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
    description: getQueryDescription(key)
  }));
};

/**
 * Helper to get query descriptions
 */
const getQueryDescription = (queryType) => {
  const descriptions = {
    struggling_students: 'Students with average grade below 60%',
    missing_assignments: 'Students with incomplete assignments',
    attendance_issues: 'Students with attendance problems',
    class_average: 'Overall class performance statistics',
    recent_improvements: 'Students who improved in the last 30 days',
    assignment_completion: 'Completion rates for all assignments'
  };
  
  return descriptions[queryType] || 'No description available';
};

module.exports = {
  executePredefinedQuery,
  executeDynamicQuery,
  testConnection,
  getAvailableQueries,
  PREDEFINED_QUERIES
};
